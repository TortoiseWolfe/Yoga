# Phase 1: Data Model - Third Test User

**Feature**: Comprehensive E2E Test Suite for User Messaging
**Branch**: `024-add-third-test`
**Date**: 2025-11-24
**Status**: Complete

## Overview

This document defines the data model for the third test user (test-user-b@example.com) that will be used in E2E testing of the messaging system.

## Test User Entity

### Primary Test User (Existing - for reference)

**Identity**:

- Email: `test@example.com`
- Password: `TestPassword123!`
- UUID: (generated by Supabase)

**Profile**:

- Username: `testuser`
- Display Name: `Test User`
- Bio: `Primary test user for E2E testing`

**Environment Variables**:

```bash
TEST_USER_PRIMARY_EMAIL=test@example.com
TEST_USER_PRIMARY_PASSWORD=TestPassword123!
```

**Purpose**: User A in E2E tests (initiates friend requests and messages)

---

### Tertiary Test User (NEW - this feature)

**Identity**:

- Email: `test-user-b@example.com`
- Password: `TestPassword456!`
- UUID: (generated by Supabase)

**Profile**:

- Username: `testuser-b`
- Display Name: `Test User B`
- Bio: `Tertiary test user for E2E testing`

**Environment Variables** (to be added to `.env`):

```bash
TEST_USER_TERTIARY_EMAIL=test-user-b@example.com
TEST_USER_TERTIARY_PASSWORD=TestPassword456!
```

**Purpose**: User B in E2E tests (receives friend requests and responds to messages)

---

## Database Schema

### auth.users (Supabase Auth Table)

**Existing Structure** (no changes):

```sql
CREATE TABLE auth.users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  encrypted_password TEXT NOT NULL,  -- bcrypt hash
  email_confirmed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  raw_app_meta_data JSONB,
  raw_user_meta_data JSONB
);
```

**New Record** (created by seed script):

```sql
INSERT INTO auth.users (
  id,
  email,
  encrypted_password,
  email_confirmed_at,
  raw_app_meta_data,
  raw_user_meta_data
) VALUES (
  gen_random_uuid(),
  'test-user-b@example.com',
  crypt('TestPassword456!', gen_salt('bf')),  -- bcrypt hash
  now(),  -- Email pre-confirmed for testing
  '{"provider": "email", "providers": ["email"]}',
  '{}'
);
```

---

### user_profiles (Application Table)

**Existing Structure** (no changes):

```sql
CREATE TABLE user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE NOT NULL,
  display_name TEXT,
  bio TEXT,
  avatar_url TEXT,
  email_verified BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
```

**New Record** (created by seed script or trigger):

```sql
INSERT INTO user_profiles (
  id,
  username,
  display_name,
  bio,
  email_verified
) VALUES (
  (SELECT id FROM auth.users WHERE email = 'test-user-b@example.com'),
  'testuser-b',
  'Test User B',
  'Tertiary test user for E2E testing',
  true  -- Pre-verified for testing
);
```

**Note**: If `handle_new_user` trigger exists, profile record may be auto-created. Seed script should check for existence before inserting.

---

## Test Data Relationships

### Connections Between Test Users

**Schema** (existing - no changes):

```sql
CREATE TABLE connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  connected_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  status TEXT CHECK (status IN ('pending', 'accepted', 'declined', 'blocked')),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(user_id, connected_user_id)
);
```

**Test Scenario Data**:

```sql
-- User A sends friend request to User B
INSERT INTO connections (user_id, connected_user_id, status)
VALUES (
  (SELECT id FROM auth.users WHERE email = 'test@example.com'),
  (SELECT id FROM auth.users WHERE email = 'test-user-b@example.com'),
  'pending'
);

-- After acceptance (bidirectional connection)
UPDATE connections SET status = 'accepted'
WHERE user_id = (SELECT id FROM auth.users WHERE email = 'test@example.com')
  AND connected_user_id = (SELECT id FROM auth.users WHERE email = 'test-user-b@example.com');

-- Reverse connection (User B → User A)
INSERT INTO connections (user_id, connected_user_id, status)
VALUES (
  (SELECT id FROM auth.users WHERE email = 'test-user-b@example.com'),
  (SELECT id FROM auth.users WHERE email = 'test@example.com'),
  'accepted'
);
```

**Cleanup Strategy**: Delete all connections where either `user_id` or `connected_user_id` matches test user UUIDs before each test run.

---

### Conversations Between Test Users

**Schema** (existing - no changes):

```sql
CREATE TABLE conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  participant_1_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  participant_2_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  last_message_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(participant_1_id, participant_2_id)
);
```

**Test Scenario Data**:

```sql
-- Conversation between User A and User B
INSERT INTO conversations (participant_1_id, participant_2_id, last_message_at)
VALUES (
  (SELECT id FROM auth.users WHERE email = 'test@example.com'),
  (SELECT id FROM auth.users WHERE email = 'test-user-b@example.com'),
  now()
);
```

**Cleanup Strategy**: Delete all conversations where either `participant_1_id` or `participant_2_id` matches test user UUIDs before each test run.

---

### Messages in Test Conversations

**Schema** (existing - no changes):

```sql
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID REFERENCES conversations(id) ON DELETE CASCADE,
  sender_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  encrypted_content TEXT NOT NULL,  -- AES-GCM ciphertext (base64)
  content_iv TEXT NOT NULL,         -- Initialization vector (base64)
  sent_at TIMESTAMPTZ DEFAULT now(),
  delivered_at TIMESTAMPTZ,
  read_at TIMESTAMPTZ
);
```

**Test Scenario Data**:

```sql
-- User A sends message to User B
INSERT INTO messages (conversation_id, sender_id, encrypted_content, content_iv)
VALUES (
  (SELECT id FROM conversations WHERE participant_1_id = ... AND participant_2_id = ...),
  (SELECT id FROM auth.users WHERE email = 'test@example.com'),
  'base64_encrypted_ciphertext_here',
  'base64_iv_here'
);

-- User B replies to User A
INSERT INTO messages (conversation_id, sender_id, encrypted_content, content_iv)
VALUES (
  (SELECT id FROM conversations WHERE participant_1_id = ... AND participant_2_id = ...),
  (SELECT id FROM auth.users WHERE email = 'test-user-b@example.com'),
  'base64_encrypted_reply_ciphertext_here',
  'base64_reply_iv_here'
);
```

**Cleanup Strategy**: Delete all messages in conversations belonging to test users before each test run (cascade delete via conversation_id).

---

## Encryption Keys (Local Storage)

**Note**: Encryption keys are stored in browser localStorage, NOT in the database. This is zero-knowledge encryption.

**Structure** (per user):

```typescript
interface EncryptionKeys {
  privateKey: CryptoKey; // ECDH private key (non-extractable)
  publicKey: CryptoKey; // ECDH public key (extractable)
}
```

**Storage Location**: `localStorage.getItem('encryption_keys_<user_id>')`

**Test Implications**:

- Each Playwright browser context gets isolated localStorage
- Keys are auto-generated on first sign-in (via AuthContext)
- Tests must allow time for key generation after sign-in
- No cleanup needed (browser context disposed after test)

---

## Test Data Lifecycle

### 1. Setup (beforeAll)

```typescript
// Verify test users exist in database
const { data: userA } = await supabase.auth.signInWithPassword({
  email: process.env.TEST_USER_PRIMARY_EMAIL!,
  password: process.env.TEST_USER_PRIMARY_PASSWORD!,
});

const { data: userB } = await supabase.auth.signInWithPassword({
  email: process.env.TEST_USER_TERTIARY_EMAIL!,
  password: process.env.TEST_USER_TERTIARY_PASSWORD!,
});

// Store UUIDs for cleanup
USER_A_ID = userA.user.id;
USER_B_ID = userB.user.id;
```

### 2. Cleanup (beforeEach)

```typescript
// Delete connections
await supabase
  .from('connections')
  .delete()
  .or(`user_id.eq.${USER_A_ID},user_id.eq.${USER_B_ID}`);

// Delete conversations (cascade deletes messages)
await supabase
  .from('conversations')
  .delete()
  .or(`participant_1_id.eq.${USER_A_ID},participant_2_id.eq.${USER_B_ID}`);
```

### 3. Test Execution

- Browser contexts simulate real user interactions
- Data created naturally through UI interactions
- Encryption happens client-side (WebCrypto API)
- Database stores only ciphertext

### 4. Verification

- Query database directly to verify encryption
- Check connection status updates
- Verify message delivery timestamps
- Confirm no plaintext in database

---

## Environment Configuration

### `.env` File Updates

**Add these lines**:

```bash
# Tertiary Test User (test-user-b@example.com)
TEST_USER_TERTIARY_EMAIL=test-user-b@example.com
TEST_USER_TERTIARY_PASSWORD=TestPassword456!
```

### `.env.example` File Updates

**Add these lines**:

```bash
# Tertiary Test User (for E2E messaging tests)
TEST_USER_TERTIARY_EMAIL=test-user-b@example.com
TEST_USER_TERTIARY_PASSWORD=TestPassword456!
```

---

## Security Considerations

### Test User Isolation

**RLS Policies** (existing - no changes needed):

- Users can only see their own connections
- Users can only see messages in their conversations
- User profiles are publicly readable (for search)

**Test Environment**:

- Service role key used ONLY for test cleanup (bypasses RLS)
- Test users have no real data or PII
- Test database separate from production

### Password Security

**Test Passwords**:

- `TestPassword123!` and `TestPassword456!` are strong (12+ chars, mixed case, numbers, symbols)
- Stored in `.env` file (NOT committed to repo)
- `.env.example` shows format only (no real passwords)

**bcrypt Hashing**:

- All passwords hashed with bcrypt (work factor 10)
- Supabase Auth handles password verification
- No plaintext passwords in database

---

## Summary

**Data Model Decisions**:

- ✅ Third test user follows same structure as primary test user
- ✅ No database schema changes required
- ✅ Reuses existing tables: auth.users, user_profiles, connections, conversations, messages
- ✅ Test data cleanup via beforeEach hooks ensures idempotency
- ✅ Environment variables keep credentials out of code

**Ready for Implementation**: All data structures defined, seed script pattern established, cleanup strategy documented.
